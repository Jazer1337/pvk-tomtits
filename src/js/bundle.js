/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../src/js/game.js":
/*!*************************!*\
  !*** ../src/js/game.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _resolution_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resolution.js */ \"../src/js/resolution.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ \"../src/js/map.js\");\n/* harmony import */ var _solve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solve.js */ \"../src/js/solve.js\");\n/* harmony import */ var _sprite_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sprite.js */ \"../src/js/sprite.js\");\n\n\n\n\n\n\nclass Game {\n    \n    static SRC_TRASH_EMPTY = \"./src/css/trash_empty.svg\";\n    static SRC_TRASH_FULL = \"./src/css/trash_full.svg\";\n\n    static canvas = document.getElementById('canvas');\n    static canvasRect;\n    static ctx = canvas.getContext('2d');\n\n    static gameOver = false;\n    static startNode;\n    static trash = [];        // list of [node, Sprite]\n    static numTrashLevels = [3, 5, 8];\n    static level = 0;\n    static allTrashSprites = [];       // 8 sprites. No more are created, only reused\n    \n    static PLAYER_PATH_COLOR = \"rgba(255, 0, 0, 0.5)\";\n    static playerTrashCollected = [];       // nodes corresponding to those in `allTrashSprites`\n    static playerScore = 0;\n    static playerCurrentNode;\n    static player;      // Sprite\n    static playerMoving = false;        // player is unable to move while animation is playing\n    static playerScoreElem;\n    \n    static ROBOT_PATH_COLOR = \"rgba(0, 0, 255, 0.5)\";\n    static robotScore = 0;\n    static robot;       // Sprite\n    static robotPath;   // Path\n    static robotIdx;    // int\n    static robotUndrawnRoads;       // list of [node1, node2]\n    static robotVisited = [];        // list of node indices\n    static robotScoreElem;\n\n    static scoreCompareElem;\n\n    static setup() {\n        \n        Game.startNode = _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.nodes[0];\n\n        Game.playerScoreElem = document.getElementById(\"score-player\").getElementsByTagName(\"div\")[0];\n        Game.robotScoreElem = document.getElementById(\"score-robot\").getElementsByTagName(\"div\")[0];\n        Game.scoreCompareElem = document.getElementById(\"score-compare\");\n\n        Game.canvasRect = Game.canvas.getBoundingClientRect();\n\n        const x = Game.startNode.x;\n        const y = Game.startNode.y;\n\n        // setup truck\n        Game.player = new _sprite_js__WEBPACK_IMPORTED_MODULE_3__.Sprite(\"./src/css/garbage_truck.svg\", 150, x, y);\n        Game.player.img.style.zIndex = 1;                                        // show on top of trash cans\n\n        // setup robot\n        Game.robot = new _sprite_js__WEBPACK_IMPORTED_MODULE_3__.Sprite(\"./src/css/ai_robot.png\", 100, x, y, false);\n        Game.robot.img.style.zIndex = 1;\n        \n        // create sprites and save (they will be reused)\n        const lastLevelNumTrash = Game.numTrashLevels[Game.numTrashLevels.length-1];\n        for (let i=0; i<lastLevelNumTrash; i++) {\n            Game.allTrashSprites[i] = new _sprite_js__WEBPACK_IMPORTED_MODULE_3__.Sprite(Game.SRC_TRASH_FULL, 100, 0, 0, false);\n        }\n        Game.generateTrash(Game.numTrashLevels[Game.level]);\n        \n        // wait for all sprites to be loaded before moving trash\n        const iId = setInterval(() => {\n            let allLoaded = true;\n            for (const sprite of Game.allTrashSprites) {\n                if (!sprite.isLoaded) {\n                    allLoaded = false;\n                    break;\n                }\n            }\n            if (allLoaded) {\n                clearInterval(iId);\n                Game.reset();\n            }            \n        }, 100);\n        \n        Game.canvas.addEventListener('click', Game.onClick);\n    }\n\n    static onClick(event) {\n        if (Game.gameOver || Game.playerMoving) {\n            return;\n        }\n        \n        const radius = 7 * _resolution_js__WEBPACK_IMPORTED_MODULE_0__.Resolution.circleRadius;     // not necessary to press exactly on the circle (outside is ok)\n        \n        const x = event.clientX - Game.canvasRect.x;\n        const y = event.clientY - Game.canvasRect.y;\n        const clickedNode = _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.nodes.find(node => Math.hypot(node.x-x, node.y-y) < radius);\n\n        // if neighbor\n        if (_map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.graph.getNeighborEdges(Game.playerCurrentNode).find(edge => edge.to == clickedNode)) {\n\n            const oldPlayerScore = Game.playerScore;\n            const edgeWeight = _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.graph.getWeight(Game.playerCurrentNode, clickedNode) * _resolution_js__WEBPACK_IMPORTED_MODULE_0__.Resolution.SCALE;\n\n            Game.player.setHorizontalFlip(clickedNode.x < Game.playerCurrentNode.x)\n\n\n            Game.drawLine(Game.playerCurrentNode, clickedNode, Game.PLAYER_PATH_COLOR);\n            Game.playerCurrentNode = clickedNode;\n\n            function onFinish() {\n\n                let collect = true;\n                for (const node of Game.playerTrashCollected) {\n                    if (node == clickedNode) {\n                        collect = false;\n                        break;\n                    }\n                }\n\n                if (collect && Game.emptyTrash(clickedNode)) {\n                    Game.playerTrashCollected.push(clickedNode);\n                };\n\n                if (Game.playerCurrentNode == Game.startNode && Game.playerTrashCollected.length == Game.trash.length){\n                    Game.gameOver = true;\n\n                    Game.updatePlayerScoreText(true);\n                    Game.drawAISolution();\n                }\n                else {\n                    Game.playerScore = oldPlayerScore + edgeWeight;\n                    Game.updatePlayerScoreText();\n                }\n\n                Game.playerMoving = false;\n            }\n\n            function onNewFrame(progress) {\n                Game.playerScore = oldPlayerScore + edgeWeight * progress;\n                Game.updatePlayerScoreText();\n            }\n\n            Game.playerMoving = true;\n            Game.player.moveToAnim(clickedNode.x, clickedNode.y, onFinish, onNewFrame);\n        } \n    }\n\n    static reset() {\n\n        // reset stats\n        Game.gameOver = false;\n        Game.playerScore = 0;\n        Game.playerCurrentNode = Game.startNode;\n        Game.playerMoving = false;\n        Game.playerTrashCollected = [];\n\n        Game.robotScore = 0;\n        Game.updatePlayerScoreText();\n        Game.updateRobotScoreText();\n\n        // reset visuals\n        Game.ctx.clearRect(0, 0, Game.canvasRect.width, Game.canvasRect.height);\n\n        const elemCompare = document.getElementById(\"score-compare\");\n        elemCompare.style.backgroundColor = \"lightgray\";\n        elemCompare.innerHTML = \"Är du klurigare än en AI?\";\n\n        Game.drawNode(Game.startNode, '#0F0')\n\n        for (const node of _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.nodes) {\n            Game.drawNode(node, '#0003');\n        }\n\n        Game.player.reset();\n        Game.robot.reset();\n        \n        for (const sprite of Game.allTrashSprites) {\n            clearInterval(sprite.intervalId);\n            sprite.setVisible(false);\n        }\n\n        for (const [node, sprite] of Game.trash) {\n            sprite.reset();\n            sprite.setVisible(true);\n            sprite.moveTo(node.x, node.y);\n        }\n\n    }\n\n    static nextLevel(step) {\n        Game.level += step;\n\n        Game.reset()        // to stop intervals\n        Game.trash = [];\n        Game.generateTrash();\n        Game.reset();           // to redraw new trash\n    }\n\n    static updatePlayerScoreText(finished=false) {\n        if (finished) {\n            this.playerScoreElem.innerHTML = \"✅ \" + Math.floor(Game.playerScore) + \" meter\";\n        }\n        else {\n            this.playerScoreElem.innerHTML = Math.floor(Game.playerScore) + \" meter\";\n        }\n    }\n    \n    static updateRobotScoreText(finished=false) {\n        if (finished) {\n            this.robotScoreElem.innerHTML = \"✅ \" + Math.floor(Game.robotScore) + \" meter\";\n        }\n        else {\n            this.robotScoreElem.innerHTML = Math.floor(Game.robotScore) + \" meter\";\n        }\n    }\n\n    static updateCompareScoreText() {\n        Game.robotScore = Math.floor(Game.robotScore);\n        Game.playerScore = Math.floor(Game.playerScore);\n        \n        const diff = Math.abs(Game.playerScore - Game.robotScore);\n        let str;\n        let color;\n\n        if (Game.playerScore == Game.robotScore) {\n            color = \"lightgreen\";\n            str = `Du är lika klurig som en AI! <br>\n                Du hittade en resväg som är lika kort som en AI:s.`;\n        }\n        else if (Game.playerScore < Game.robotScore) {\n            color = \"lightgreen\";\n            str = `Du är klurigare än en AI! <br>\n                Du hittade en resväg som var ${diff} meter kortare än en AI:s.`;\n        }\n        else {\n            color = \"orange\";\n            str =\n                `Bra försök! <br>\n                Du hittade en resväg som var ${diff} meter längre än en AI:s.`;\n        }\n\n        Game.scoreCompareElem.style.backgroundColor = color;\n        Game.scoreCompareElem.innerHTML = str;\n        Game.scoreCompareElem.style.visibility = \"visible\";\n    }\n\n    static drawNode(node, color) {\n        Game.ctx.fillStyle = color;\n        Game.ctx.beginPath();\n        Game.ctx.arc(node.x, node.y, _resolution_js__WEBPACK_IMPORTED_MODULE_0__.Resolution.circleRadius, 0, Math.PI * 2);\n        Game.ctx.fill();\n\n        Game.ctx.font = '30px Arial';             // Set font size and family\n        Game.ctx.fillStyle = 'blue';              // Set text color\n        Game.ctx.textAlign = 'center';            // Set text alignment\n        Game.ctx.textBaseline = 'middle';         // Set text baseline\n        Game.ctx.fillText(node.name, node.x+40, node.y);\n\n    }\n\n    static drawLine(node1, node2, color) {\n        Game.ctx.strokeStyle = color;\n        Game.ctx.lineWidth = 2;\n        Game.ctx.beginPath();\n        Game.ctx.moveTo(node1.x, node1.y);\n        Game.ctx.lineTo(node2.x, node2.y);\n        Game.ctx.stroke();\n    }\n\n    static generateTrash() {\n        \n        let nodesLeft = [..._map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.nodes];\n\n        for (let i=0; i<Game.numTrashLevels[Game.level]; i++) {\n            \n            // pick random trash\n            const randIdx = Math.floor(Math.random() * (nodesLeft.length - 1) + 1);\n            const node = nodesLeft.splice(randIdx, 1)[0];\n\n            Game.trash[i] = [node, Game.allTrashSprites[i]];\n            \n        }\n    }\n\n    static drawAISolution() {\n        \n        Game.robot.setVisible(true);\n\n        // find solution\n        const start = _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.nodes[0];\n        \n        let nodeTargets = [];\n        for (const [node, _] of Game.trash) {\n            nodeTargets.push(node);\n        }     \n\n        let robotPath = (0,_solve_js__WEBPACK_IMPORTED_MODULE_2__.FindShortestPathAll)(_map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.graph, start, nodeTargets);\n\n        let robotIdx = 0;      // first idx of `path`\n\n        let robotUndrawnRoads = [];\n        for (let i=0; i<robotPath.nodes.length-1; i++) {\n            const node1 = robotPath.nodes[i];\n            const node2 = robotPath.nodes[i+1];\n\n            let add = true;\n            for (const [n1, n2] of robotUndrawnRoads) {\n                if (n1 == node2 && n2 == node1) {\n                    add = false;\n                    break;\n                }\n            }\n\n            if (add) {\n                robotUndrawnRoads.push([node1, node2]);\n            }\n        }\n\n        // refill trash\n        for (const [_, sprite] of Game.trash) {\n            sprite.img.src = Game.SRC_TRASH_FULL;\n        }\n\n        Game.ctx.setLineDash([10, 10]);\n\n        let oldRobotScore;\n        let edgeWeight;\n        let newNode;\n\n        function moveToNextNode() {\n            robotIdx++;\n\n            if (robotIdx == robotPath.nodes.length) {\n                Game.updateRobotScoreText(true);\n                Game.updateCompareScoreText();\n                Game.ctx.setLineDash([]);\n                return;\n            }\n\n            newNode = robotPath.nodes[robotIdx];\n            const oldNode = robotPath.nodes[robotIdx-1];\n\n            Game.drawLine(oldNode, newNode, Game.ROBOT_PATH_COLOR);\n\n            oldRobotScore = Game.robotScore;\n            edgeWeight = _map_js__WEBPACK_IMPORTED_MODULE_1__.GameMap.graph.getWeight(oldNode, newNode) * _resolution_js__WEBPACK_IMPORTED_MODULE_0__.Resolution.SCALE;\n            Game.robot.moveToAnim(newNode.x, newNode.y, onFinish, onNewFrame);\n\n        }\n\n        function onFinish() {\n            Game.emptyTrash(newNode);  // NOTE: will empty even if already empty, but doesn't matter\n                                       // since it's not being tracked.\n\n            Game.robotScore = oldRobotScore + edgeWeight;\n            Game.updateRobotScoreText();\n\n            setTimeout(() => {\n                moveToNextNode();       // wait before moving to next trash\n            }, 250);\n        }\n\n        function onNewFrame(progress) {\n            Game.robotScore = oldRobotScore + edgeWeight * progress;\n            Game.updateRobotScoreText();\n        }\n\n        setTimeout(moveToNextNode, 1000);\n    }\n\n    static emptyTrash(node) {\n        for (const [n, sprite] of Game.trash) {\n            if (n == node) {\n                sprite.img.src = Game.SRC_TRASH_EMPTY;\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/game.js?");

/***/ }),

/***/ "../src/js/graph.js":
/*!**************************!*\
  !*** ../src/js/graph.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   Node: () => (/* binding */ Node)\n/* harmony export */ });\n\nclass Node {\n    /**\n     * @param {number} name \n     * @param {number} x \n     * @param {number} y \n     */\n    constructor(name, x, y) {\n        this.name = name;\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Edge {\n    /**\n     * @param {Node} to \n     * @param {number} weight \n    */\n    constructor(to, weight) {\n        this.to = to;\n        this.weight = weight;\n    }\n}\n\nclass Graph {\n    constructor() {\n        /** @type {Map<Node, Array<Edge>>} */\n        this.edges = new Map();\n    }\n\n    /**\n     * @param {Node} node1\n     * @param {Node} node2\n     */\n    addEdge(node1, node2) {\n        // TODO: prevent duplicate edges\n        if (this.edges.get(node1) === undefined) {\n            this.edges.set(node1, []);\n        }\n        if (this.edges.get(node2) === undefined) {\n            this.edges.set(node2, []);\n        }\n\n        let dist = Math.hypot(node2.x-node1.x, node2.y - node1.y);\n        this.edges.get(node1).push(new Edge(node2, dist));\n        this.edges.get(node2).push(new Edge(node1, dist));\n    }\n\n    /**\n     * @param {number} node1 \n     * @param {number} node2 \n     * @returns {number}\n     */\n    getWeight(node1, node2) {\n\n        for (let e of this.edges.get(node1)) {\n            if (e.to == node2) {\n                return e.weight;\n            }\n        }\n    }\n\n    /**\n     * @returns {IterableIterator<number>}\n     */\n    getNodes() {\n        return this.edges.keys();\n    }\n\n    /**\n     * @param {number} node \n     * @returns {Array<Edge>}\n     */\n    getNeighborEdges(node) {\n        return this.edges.get(node);\n    }\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/graph.js?");

/***/ }),

/***/ "../src/js/index.js":
/*!**************************!*\
  !*** ../src/js/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _resolution_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resolution.js */ \"../src/js/resolution.js\");\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game.js */ \"../src/js/game.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"../src/js/map.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui.js */ \"../src/js/ui.js\");\n\n\n\n\n\n\n_resolution_js__WEBPACK_IMPORTED_MODULE_0__.Resolution.setup();     // resolution must be set up first\n_ui_js__WEBPACK_IMPORTED_MODULE_3__.UI.setup();\n_map_js__WEBPACK_IMPORTED_MODULE_2__.GameMap.setup();\n\n_game_js__WEBPACK_IMPORTED_MODULE_1__.Game.setup();\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/index.js?");

/***/ }),

/***/ "../src/js/map.js":
/*!************************!*\
  !*** ../src/js/map.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameMap: () => (/* binding */ GameMap)\n/* harmony export */ });\n/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph.js */ \"../src/js/graph.js\");\n\n\nclass GameMap {\n    \n    static nodes = [];\n    static graph = new _graph_js__WEBPACK_IMPORTED_MODULE_0__.Graph();\n\n    static setup() {\n        \n        // Nodes are accessed with indexes (nodes[0] gives first node).\n        // These positions are based on 1920x1080\n        let nodePos = [\n            [ 0,  195,   70],\n            [ 1,  174,  181],\n            [ 2,  342,  145],\n            [ 3,  128,  450],\n            [ 4,  215,  645],\n            [ 5,  343,  931],\n            [ 6,  527,  613],\n            [ 7,  735,  592],\n            [ 8,  762,  887],\n            [ 9, 1118,  850],\n            [10, 1294, 1017],\n            [11, 1575,  988],\n            [12, 1307,  689],\n            [13, 1588,  661],\n            [14, 1311,  531],\n            [15, 1053,  558],\n            [16,  994,  265],\n            [17,  698,  324],\n            [18,  863,   32],\n            [19, 1320,   92],\n            [20, 1253,  210],\n            [21, 1605,  135],\n            [22, 1600,  292],\n            [23, 1593,  502],\n            [24, 1847,  474],\n        ];\n\n        // [node1.num, node2.num]\n        let edges = [\n            [ 0,  1],\n            [ 0,  2],\n            [ 1,  2],\n            [ 1,  3],\n            [ 2, 17],\n            [ 2, 18],\n            [ 3,  4],\n            [ 3, 17],\n            [ 3,  4],\n            [ 4,  5],\n            [ 4,  6],\n            [ 5,  6],\n            [ 5,  8],\n            [ 6,  7],\n            [ 6, 17],\n            [ 7,  8],\n            [ 7, 17],\n            [ 7, 15],\n            [ 8,  9],\n            [ 9, 10],\n            [ 9, 12],\n            [ 9, 15],\n            [10, 11],\n            [10, 12],\n            [11, 13],\n            [11, 24],\n            [12, 13],\n            [12, 14],\n            [13, 23],\n            [14, 15],\n            [14, 23],\n            [14, 22],\n            [15, 16],\n            [15, 20],\n            [16, 17],\n            [16, 20],\n            [17, 18],\n            [18, 19],\n            [19, 20],\n            [20, 21],\n            [21, 22],\n            [22, 24],\n            [22, 23],\n            [23, 24],\n        ];\n\n        const w = document.getElementById(\"canvas\").width;\n        const h = document.getElementById(\"canvas\").height;\n\n        for (let [i, x, y] of nodePos) {\n            x = Math.floor(x * (w/1920));\n            y = Math.floor(y * (h/1080));\n            this.nodes.push(new _graph_js__WEBPACK_IMPORTED_MODULE_0__.Node(i, x, y));\n        }\n\n        for (let e of edges) {\n            this.graph.addEdge(this.nodes[e[0]], this.nodes[e[1]]);\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/map.js?");

/***/ }),

/***/ "../src/js/resolution.js":
/*!*******************************!*\
  !*** ../src/js/resolution.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Resolution: () => (/* binding */ Resolution)\n/* harmony export */ });\n\nclass Resolution {\n\n    static SCALE;       // used for scaling images and props on the game map\n    \n    static circleRadius = 10;       // for 1920x1080\n\n    static setup() {  \n\n        const marginBetweenCols = parseInt(window.getComputedStyle(document.getElementById(\"column-2\")).marginLeft);\n\n        const margin = 20;\n\n        const desiredW = 1920 + 350;\n        const desiredH = 1080;\n\n        let desiredRatio = desiredW / desiredH;\n        \n        let winW = window.innerWidth - 2*margin - marginBetweenCols;\n        let winH = window.innerHeight - 2*margin;\n        \n        let winRatio = winW / winH;\n        \n        let totalW, totalH;\n        if (winRatio > desiredRatio) {\n            totalH = winH;\n            totalW = totalH * desiredRatio;     // screen is wider: height constrains svg size\n        }\n        else {\n            totalW = winW;\n            totalH = totalW / desiredRatio;       // screen is taller/same aspect ratio: width constrains svg size\n        }\n\n        this.SCALE = desiredW / totalW;\n\n        // set sizes based on potential new ratio\n        this.circleRadius = this.circleRadius * totalW / 1920;\n\n        const col1 = document.getElementById(\"column-1\");\n        col1.style.width = (1920/1080) * totalH + \"px\";\n        col1.style.height = totalH + \"px\";\n\n        const col2 = document.getElementById(\"column-2\");\n        col2.style.width = totalW - parseInt(col1.style.width) + \"px\";\n        col2.style.height = totalH + \"px\";\n        col2.style.marginLeft = marginBetweenCols + \"px\";\n\n\n        // set **internal** size for canvas. Can be set in the element in html (or here in js) but not in css.\n        const canvas = document.getElementById(\"canvas\");\n        canvas.width = parseInt(col1.style.width);      // NOTE: without \"px\"\n        canvas.height = parseInt(col1.style.height);\n\n        canvas.style.width = col1.style.width;\n        canvas.style.height = col1.style.height;\n\n        const scorePlayer = document.getElementById(\"score-player\");\n        const scorePlayerImg = scorePlayer.getElementsByTagName(\"img\")[0];\n        scorePlayerImg.style.width = 100 / this.SCALE + \"px\";\n        \n        const scoreRobot = document.getElementById(\"score-robot\");\n        const scoreRobotImg = scoreRobot.getElementsByTagName(\"img\")[0];\n        scoreRobotImg.style.width = 75 / this.SCALE + \"px\";\n\n    }\n\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/resolution.js?");

/***/ }),

/***/ "../src/js/solve.js":
/*!**************************!*\
  !*** ../src/js/solve.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FindShortestPathAll: () => (/* binding */ FindShortestPathAll)\n/* harmony export */ });\n\nclass Path {\n    constructor() {\n        this.cost = 0;\n        this.nodes = [];\n    }\n}\n\n/**\n * Include all nodes in `nodes` when finding path.\n * Automatically adds `startNode` as end node.\n * @param {Node} startNode \n * @param {Array<number>} unvisited \n */\nfunction FindShortestPathAll(graph, startNode, unvisited) {\n\n    let pathCombined = new Path();\n    pathCombined.nodes.push(startNode);\n\n    let from = startNode;\n\n    while (unvisited.length > 0) {\n        \n        let lastPath = null;\n\n        for (let node of unvisited) {\n    \n            let path = FindShortestPathBetween(graph, from, node);\n\n            if (lastPath === null || path.cost < lastPath.cost) {\n                lastPath = path;\n            }\n        }\n\n        from = lastPath.nodes[lastPath.nodes.length-1];\n\n        unvisited = unvisited.filter(unvNode => !lastPath.nodes.includes(unvNode));\n\n        // don't append first node (was appended last iteration)\n        pathCombined.nodes.push(...lastPath.nodes.slice(1));\n        pathCombined.cost += lastPath.cost;\n    }\n\n    // connect back to startNode\n    from = pathCombined.nodes[pathCombined.nodes.length-1];\n    let path = FindShortestPathBetween(graph, from, startNode);\n\n    pathCombined.nodes.push(...path.nodes.slice(1));\n    pathCombined.cost += path.cost;\n\n    return pathCombined;\n}\n\n/**\n * Dijkstra's algorithm: find shortest path between nodes in weighted, directed graph.\n * (pseudo code at: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n * @returns {Path}\n */\nfunction FindShortestPathBetween(graph, startNode, endNode) {\n\n    // setup\n    let distanceTo = new Map();\n    let parentOf = new Map();\n    let queue = [];\n\n    for (let v of graph.getNodes()) {\n        distanceTo.set(v, Infinity);\n        parentOf.set(v, -1);\n        queue.push(v);\n    }\n    distanceTo.set(startNode, 0);\n\n    // Dijkstra\n    while (queue.length > 0) {\n\n        // get min dist node\n        let u = null;\n        let minDist = Infinity;\n\n        for (let [node, dist] of distanceTo.entries()) {\n            if (dist < minDist && queue.includes(node)) {\n                u = node;\n                minDist = dist;\n            }\n        }\n\n        // break early if possible, since we don't need the min distance to all nodes\n        if (u == endNode) {\n            break;\n        }\n\n        // remove from queue\n        let idx = queue.indexOf(u);\n        queue.splice(idx, 1);\n\n        // update min dist\n        for (let edge of graph.getNeighborEdges(u)) {\n            let v = edge.to;\n            let alt = distanceTo.get(u) + edge.weight;\n            if (alt < distanceTo.get(v)) {\n                distanceTo.set(v, alt);\n                parentOf.set(v, u);\n            }\n        }\n    }\n\n    // build path in reverse\n    let path = new Path();\n    let u = endNode;\n\n    while (true) {\n        path.nodes.unshift(u);\n        if (parentOf.get(u) == -1) {\n            break;\n        }\n        path.cost += graph.getWeight(parentOf.get(u), u);\n        u = parentOf.get(u);\n    }\n\n    return path;\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/solve.js?");

/***/ }),

/***/ "../src/js/sprite.js":
/*!***************************!*\
  !*** ../src/js/sprite.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sprite: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"../src/js/game.js\");\n/* harmony import */ var _resolution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolution.js */ \"../src/js/resolution.js\");\n\n\n\n\nclass Sprite {\n\n    x;      // left\n    y;      // top\n    WIDTH;\n    HEIGHT;\n\n    img;    // HTML elem\n\n    intervalId;     // for moveToAnim\n\n    ORIG_IMG_SRC;     // used to reset\n    ORIG_X;\n    ORIG_Y;\n    ORIG_VISIBLE;\n\n    isLoaded = false;       // used to move generated trash\n\n    // NOTE: x, y will be center\n    constructor(imgSrc, width, x, y, visible=true) {\n        \n        this.ORIG_IMG_SRC = imgSrc;\n        this.ORIG_X = x;\n        this.ORIG_Y = y;\n        this.ORIG_VISIBLE = visible;\n\n        this.img = new Image(width);\n        \n        document.getElementById(\"column-1\").appendChild(this.img);\n\n        this.img.src = imgSrc;\n        this.img.onload = () => {\n            const ratio = this.img.width / this.img.height;\n            const w = Math.floor(width / _resolution_js__WEBPACK_IMPORTED_MODULE_1__.Resolution.SCALE);\n            const h = Math.floor(w / ratio);\n\n            this.img.style.position = \"absolute\";\n            this.img.style.width = w + \"px\";\n            this.img.style.height = h + \"px\";\n\n            this.img.style.pointerEvents = \"none\";       // ignore events, since they should go to canvas, not this img\n\n            this.WIDTH = w;\n            this.HEIGHT = h;\n\n            this.moveTo(x, y);\n\n            this.img.onload = () => {};\n            this.isLoaded = true;\n        }\n    }\n\n    reset() {\n        clearInterval(this.intervalId);\n        this.img.src = this.ORIG_IMG_SRC;\n        this.moveTo(this.ORIG_X, this.ORIG_Y);\n        this.setVisible(this.ORIG_VISIBLE);\n    }\n\n    setVisible(v) {\n        this.img.style.visibility = v ? \"visible\" : \"hidden\";\n    }\n\n    setHorizontalFlip(v) {\n        this.img.style.transform = v ? \"scaleX(-1)\" : \"scaleX(1)\";\n    }\n\n    moveTo(x, y, centered=true) {\n        \n        this.x = x;\n        this.y = y;\n\n        if (centered) {\n            this.x -= this.WIDTH/2;\n            this.y -= this.HEIGHT/2;\n        }\n\n        this.img.style.left = _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.canvasRect.x + Math.floor(this.x) + \"px\";\n        this.img.style.top = _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.canvasRect.y + Math.floor(this.y) + \"px\";\n    }\n\n    moveBy(dx, dy) {\n        this.x += dx;\n        this.y += dy;\n\n        this.img.style.left = _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.canvasRect.x + Math.floor(this.x) + \"px\";\n        this.img.style.top = _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.canvasRect.y + Math.floor(this.y) + \"px\";\n    }\n\n    moveToAnim(x, y, onFinish, onNewFrame=()=>{}) {\n\n        x -= this.WIDTH/2;      // final x,y should be for topleft, not center\n        y -= this.HEIGHT/2;\n\n        const distX = x - this.x;\n        const distY = y - this.y;\n       \n        const dist = Math.hypot(distX, distY);\n\n        const fps = 30;\n        const speed = 500 / _resolution_js__WEBPACK_IMPORTED_MODULE_1__.Resolution.SCALE;       // pixels/second\n        const interval = 1000/fps;\n\n        const dx = (distX / dist) * speed / fps;\n        const dy = (distY / dist) * speed / fps;\n\n        const moveRight = dx > 0;\n\n        // -- uncomment to skip animation\n\n        // this.moveTo(x, y, false);\n        // onFinish();\n        // return;\n\n        const FRAMES = Math.floor(dist/speed*fps);\n        let frame = 0;        \n\n        this.intervalId = setInterval(() => {\n\n            onNewFrame(frame/FRAMES);\n            frame++;\n\n            if ((moveRight && this.x+dx >= x) || (!moveRight && this.x+dx <= x)) {\n                this.moveTo(x, y, false);\n                clearInterval(this.intervalId);\n                onFinish();\n            }\n            else {\n                this.moveBy(dx, dy);\n            }\n            \n        }, interval);\n\n    }\n\n}\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/sprite.js?");

/***/ }),

/***/ "../src/js/ui.js":
/*!***********************!*\
  !*** ../src/js/ui.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UI: () => (/* binding */ UI)\n/* harmony export */ });\n/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game.js */ \"../src/js/game.js\");\n\n\nclass UI {\n\n    static setup() {\n\n        // level button\n        const btnNext = document.getElementById(\"button-next-level\");\n        const btnLast = document.getElementById(\"button-last-level\");\n        const btnNew = document.getElementById(\"button-new-trash\");\n        const span = document.getElementById(\"span-level\");\n        \n        btnLast.disabled = true;\n\n        btnLast.addEventListener(\"click\", () => {\n            if (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level > 0) {\n                _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.nextLevel(-1);\n                span.innerHTML = \"Nivå \" + (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level+1);\n                btnNext.disabled = false;\n            }\n            if (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level == 0) {\n                btnLast.disabled = true;\n            }\n        });\n        \n        btnNext.addEventListener(\"click\", () => {\n            if (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level < 2) {\n                _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.nextLevel(+1);\n                span.innerHTML = \"Nivå \" + (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level+1);\n                btnLast.disabled = false;\n            }\n            if (_game_js__WEBPACK_IMPORTED_MODULE_0__.Game.level == 2) {\n                btnNext.disabled = true;\n            }\n        });\n\n        btnNew.addEventListener(\"click\", () => {\n            _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.nextLevel(0);      // no change in level just regenerates random trash\n        });\n\n        // reset button\n        let btn = document.getElementById(\"button-reset-level\");\n        btn.addEventListener(\"click\", _game_js__WEBPACK_IMPORTED_MODULE_0__.Game.reset);\n\n    }\n}\n\n\n//# sourceURL=webpack://pvk-tomtits/../src/js/ui.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../src/js/index.js");
/******/ 	
/******/ })()
;